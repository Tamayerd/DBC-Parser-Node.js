import { DataType, EndianType } from '../shared/DataTypes';
/**
 * Creates a DBC instance that allows for parsing/loading of an existing DBC file
 * or write data to a new DBC file.
 *
 * If loading data from an existing file, simply call:
 * const dbc = new Dbc();
 * dbc.load('path/to/my/dbcFile.dbc')
 *
 * load() loads the dbc data async., so to pull the data from the class instance
 * you will either need to wrap the call in an async function or call .then(data)
 * ex. dbc.load('path/to/my/dbcFile.dbc').then( data => DO SOMETHING WITH DATA HERE )
 *
 * By default, when a new Dbc() instance is created, the encapulsated data will be empty.
 * If you are wanting to create fresh data you can call createMessage or createSignal to
 * create messages and signals, respectively.
 * Calls to createMessage and createSignal do not by default add the messages to the data,
 * you will need to make subsequent calls to addMessage or addSignal to add the data
 * to the class.
 *
 * To write data to a dbc file, you can call write() function.
 * write() expects a path to the dbc file
 *
 */
declare class Dbc {
    data: DbcData;
    errors: Map<number, SyntaxError[]>;
    constructor();
    /**
     * Adds a version number to dbc data
     */
    set version(version: string);
    /**
     * Adds a short description for the DBC data
     */
    set description(description: string);
    /**
     *
     * Creates a Message instance that can later be added using addMessage()
     * or using the attached method .add()
     *
     * Ex.
     * let msg = dbc.createMessage('MessageName',100,8);
     * msg.add(); or dbc.addMessage(msg);
     *
     * @param name Name of CAN message
     * @param id ID of CAN message
     * @param dlc Data Length Code (data length) of CAN message
     * @param options Optional attributes that can be used when creating a message: signals, attributes, signalGroups,
     * sendingNode, and description
     * @returns Message
     */
    createMessage(name: string, id: number, dlc: number, options?: AdditionalMessageOptions): Message;
    /**
     *
     * Adds/appends message to existing message list
     *
     * @param message Message object to be added
     */
    addMessage(message: Message | Message[]): void;
    removeMessage(messageName: string): void;
    createSignal(name: string, startBit: number, length: number, options?: AdditionalSignalOptions): Signal;
    removeSignal(signalName: string, messageName: string): void;
    /**
     *
     * Adds a Signal object to a specified Message
     *
     * @param messageName Name of the message the signal will be added to
     * @param signal Signal object to be added to the specified message
     */
    addSignal(messageName: string, signal: Signal | Signal[]): void;
    /**
     *
     * Returns a message with the corresponding CAN ID. If message does not exist
     * a MessageDoesNotExist error will be thrown.
     *
     * @param id The CAN ID of the message wanting to be found
     * @returns Message
     * @throws MessageDoesNotExist
     */
    getMessageById(id: number): Message;
    /**
     *
     * Finds a specific message within the DBC file data by name
     *
     * @param name string
     * @returns Message
     * @error MessageDoesNotExist
     */
    getMessageByName(name: string): Message | undefined;
    /**
     *
     * Returns a signal object located in a specific CAN message by name
     *
     * @param name string
     * @param messageName string
     * @returns Signal
     * @error SignalDoesNotExist
     */
    getSignalByName(name: string, messageName: string): Signal;
    /**
     *
     * @param file string
     * @returns Promise<DbcData>
     */
    load(file: string, throwOnError?: boolean): Promise<DbcData>;
    /**
     * Loads a DBC file syncrhonously, as opposed to the default method 'load', which is
     * a non-blocking/async call whos promise must be caught for the return data to be used.
     *
     * @param file Full file path to the dbc file, including extension
     * @returns DbcData Data contained in the dbc file
     */
    loadSync(file: string, throwOnError?: boolean): DbcData;
    /**
     *
     * Writes the encapsulated data of a Dbc class instance to a dbc file
     *
     * @param filePath Path to the file/dbc to be written to. If it does not exist at the path, the file
     * will automatically be created.
     */
    write(filePath: string): void;
    /**
     *
     * Transforms the internal DBC data from class instance into a JSON object/string
     *
     * @param pretty Determines if JSON output should be formatted. Defaults to true.
     * @returns JSON representation of loaded DBC data
     */
    toJson(options?: {
        pretty: boolean;
    }): string;
    initDbcDataObj(): DbcData;
}
export default Dbc;
export declare type Signals = Map<string, Signal>;
export declare type AdditionalSignalOptions = {
    signed?: boolean;
    endian?: EndianType;
    min?: number;
    max?: number;
    factor?: number;
    offset?: number;
    isFloat?: boolean;
    unit?: string;
    description?: string;
    multiplex?: string;
    receivingNodes?: string[];
    valueTable?: ValueTable;
    attributes?: Attributes;
};
export declare type Signal = {
    name: string;
    multiplex: string | null;
    startBit: number;
    length: number;
    endian: EndianType;
    signed: boolean;
    factor: number;
    offset: number;
    min: number;
    max: number;
    unit: string;
    receivingNodes: string[];
    description: string | null;
    valueTable: ValueTable | null;
    attributes: Attributes;
    dataType: DataType | undefined;
};
export declare type SignalGroups = Map<string, SignalGroup>;
export declare type SignalGroup = {
    name: string;
    id: number;
    groupId: number;
    signals: string[];
};
export declare type AdditionalMessageOptions = {
    signals?: Signals;
    attributes?: Attributes;
    signalGroups?: SignalGroups;
    sendingNode?: string;
    description?: string;
};
export declare type Message = {
    name: string;
    id: number;
    dlc: number;
    sendingNode: string | null;
    signals: Map<string, Signal>;
    description: string | null;
    attributes: Attributes;
    signalGroups: SignalGroups;
    add: () => Message;
    addSignal: (name: string, startBit: number, length: number, options?: AdditionalSignalOptions) => Message;
    updateDescription: (content: string) => Message;
    updateNode: (node: string) => Message;
};
export declare type EnvType = 'Integer' | 'Float' | 'String';
export declare type AccessType = 'Unrestricted' | 'Read' | 'Write' | 'ReadWrite';
export declare type EnvironmentVariable = {
    name: string;
    type: EnvType;
    min: number;
    max: number;
    initalValue: number;
    evId: number;
    accessType: AccessType;
    accessNode: string;
    attributes: Attributes;
    valueTable: ValueTable | null;
    description: string | null;
    dataBytesLength: number | null;
    unit: string;
};
export declare type Node = {
    name: string;
    description: string | null;
    attributes: Attributes;
};
export declare type TxMessages = string[];
export declare type CanId = number;
export declare type NetworkBridges = Map<CanId, TxMessages>;
export declare type DbcData = {
    version: string | null;
    messages: Map<string, Message>;
    description: string | null;
    busSpeed: number | null;
    nodes: Map<string, Node>;
    valueTables: Map<string, ValueTable> | null;
    attributes: Attributes;
    newSymbols: string[];
    environmentVariables: Map<string, EnvironmentVariable>;
    networkBridges: NetworkBridges;
};
export declare type ValueTable = Map<number, string>;
export declare type AttributeOptions = {
    value?: string;
    defaultValue?: string;
    options?: string[];
    min?: number;
    max?: number;
};
export declare type Attributes = Map<string, Attribute>;
export declare type AttributeType = 'Global' | 'Message' | 'Signal' | 'Node' | 'EnvironmentVariable';
export declare type AttributeDataType = 'FLOAT' | 'STRING' | 'ENUM' | 'INT' | 'HEX';
export declare type Attribute = {
    name: string;
    type: AttributeType;
    dataType: AttributeDataType;
    value: string | null;
    defaultValue: string | null;
    options: string[] | null;
    min: number | null;
    max: number | null;
};
