"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const readline = __importStar(require("readline"));
const dbcParser_1 = __importDefault(require("../parser/dbcParser"));
const Writer_1 = __importDefault(require("./Writer"));
const Errors_1 = require("./Errors");
const DataTypes_1 = require("../shared/DataTypes");
const FileHandlers_1 = require("../shared/FileHandlers");
/**
 * Creates a DBC instance that allows for parsing/loading of an existing DBC file
 * or write data to a new DBC file.
 *
 * If loading data from an existing file, simply call:
 * const dbc = new Dbc();
 * dbc.load('path/to/my/dbcFile.dbc')
 *
 * load() loads the dbc data async., so to pull the data from the class instance
 * you will either need to wrap the call in an async function or call .then(data)
 * ex. dbc.load('path/to/my/dbcFile.dbc').then( data => DO SOMETHING WITH DATA HERE )
 *
 * By default, when a new Dbc() instance is created, the encapulsated data will be empty.
 * If you are wanting to create fresh data you can call createMessage or createSignal to
 * create messages and signals, respectively.
 * Calls to createMessage and createSignal do not by default add the messages to the data,
 * you will need to make subsequent calls to addMessage or addSignal to add the data
 * to the class.
 *
 * To write data to a dbc file, you can call write() function.
 * write() expects a path to the dbc file
 *
 */
class Dbc {
    constructor() {
        this.errors = new Map();
        this.data = this.initDbcDataObj();
    }
    /**
     * Adds a version number to dbc data
     */
    set version(version) {
        this.data.version = version;
    }
    /**
     * Adds a short description for the DBC data
     */
    set description(description) {
        this.data.description = description;
    }
    /**
     *
     * Creates a Message instance that can later be added using addMessage()
     * or using the attached method .add()
     *
     * Ex.
     * let msg = dbc.createMessage('MessageName',100,8);
     * msg.add(); or dbc.addMessage(msg);
     *
     * @param name Name of CAN message
     * @param id ID of CAN message
     * @param dlc Data Length Code (data length) of CAN message
     * @param options Optional attributes that can be used when creating a message: signals, attributes, signalGroups,
     * sendingNode, and description
     * @returns Message
     */
    createMessage(name, id, dlc, options) {
        // TODO: Check that ID does not exceed max range
        let signals;
        let attributes;
        let signalGroups;
        let sendingNode;
        let description;
        options && options.signals ? (signals = options.signals) : (signals = new Map());
        options && options.attributes ? (attributes = options.attributes) : (attributes = new Map());
        options && options.signalGroups ? (signalGroups = options.signalGroups) : (signalGroups = new Map());
        options && options.description ? (description = options.description) : (description = null);
        options && options.sendingNode ? (sendingNode = options.sendingNode) : (sendingNode = null);
        if (sendingNode) {
            this.data.nodes.set(sendingNode, { name: sendingNode, attributes: new Map(), description: null });
        }
        const message = {
            name,
            id,
            dlc,
            sendingNode,
            signals,
            description,
            attributes,
            signalGroups,
            add: () => {
                this.addMessage(message);
                return message;
            },
            addSignal: (signalName, startBit, length, additionalOptions) => {
                const signal = this.createSignal(signalName, startBit, length, additionalOptions);
                this.addSignal(message.name, signal);
                return message;
            },
            updateDescription: (content) => {
                message.description = content;
                return message;
            },
            updateNode: (node) => {
                message.sendingNode = node;
                this.data.nodes.set(node, { name: node, attributes: new Map(), description: null });
                return message;
            },
        };
        return message;
    }
    /**
     *
     * Adds/appends message to existing message list
     *
     * @param message Message object to be added
     */
    addMessage(message) {
        const errorOnDuplicate = (name) => {
            if (this.data.messages.has(name)) {
                throw new Error(`Can not add message ${name} as ${name} already exists. Unique message names are required.`);
            }
        };
        if (Array.isArray(message)) {
            message.forEach((msg) => {
                errorOnDuplicate(msg.name);
                this.data.messages.set(msg.name, msg);
            });
        }
        else {
            errorOnDuplicate(message.name);
            this.data.messages.set(message.name, message);
        }
    }
    removeMessage(messageName) {
        this.data.messages.delete(messageName);
    }
    createSignal(name, startBit, length, options) {
        let min;
        let max;
        let factor;
        let offset;
        let isFloat;
        let signed;
        let endian;
        let dataType;
        let unit;
        let description;
        let multiplex;
        let receivingNodes;
        let valueTable;
        let attributes;
        options && options.signed ? (signed = options.signed) : (signed = false);
        options && options.endian ? (endian = options.endian) : (endian = 'Intel');
        options && options.min ? (min = options.min) : (min = 0);
        options && options.max ? (max = options.max) : (max = 0);
        options && options.offset ? (offset = options.offset) : (offset = 0);
        options && options.factor ? (factor = options.factor) : (factor = 1);
        options && options.isFloat ? (isFloat = options.isFloat) : (isFloat = false);
        options && options.unit ? (unit = options.unit) : (unit = '');
        options && options.description ? (description = options.description) : (description = null);
        options && options.multiplex ? (multiplex = options.multiplex) : (multiplex = null);
        options && options.receivingNodes ? (receivingNodes = options.receivingNodes) : (receivingNodes = []);
        options && options.valueTable ? (valueTable = options.valueTable) : (valueTable = null);
        options && options.attributes ? (attributes = options.attributes) : (attributes = new Map());
        dataType = (0, DataTypes_1.computeDataType)(length, signed, isFloat);
        if (receivingNodes.length) {
            receivingNodes.forEach((node) => {
                this.data.nodes.set(node, { name: node, attributes: new Map(), description: null });
            });
        }
        const signal = {
            name,
            multiplex,
            startBit,
            length,
            endian,
            signed,
            factor,
            offset,
            min,
            max,
            unit,
            receivingNodes,
            description,
            valueTable,
            attributes,
            dataType,
        };
        return signal;
    }
    removeSignal(signalName, messageName) {
        const msg = this.getMessageByName(messageName);
        msg === null || msg === void 0 ? void 0 : msg.signals.delete(signalName);
    }
    /**
     *
     * Adds a Signal object to a specified Message
     *
     * @param messageName Name of the message the signal will be added to
     * @param signal Signal object to be added to the specified message
     */
    addSignal(messageName, signal) {
        const message = this.data.messages.get(messageName);
        if (message) {
            if (Array.isArray(signal)) {
                signal.forEach((sig) => {
                    message.signals.set(sig.name, sig);
                });
            }
            else {
                message.signals.set(signal.name, signal);
            }
        }
        else {
            throw new Errors_1.MessageDoesNotExist(`No message with name ${messageName} exists in the database.`);
        }
    }
    /**
     *
     * Returns a message with the corresponding CAN ID. If message does not exist
     * a MessageDoesNotExist error will be thrown.
     *
     * @param id The CAN ID of the message wanting to be found
     * @returns Message
     * @throws MessageDoesNotExist
     */
    getMessageById(id) {
        const messages = this.data.messages;
        for (const [name, message] of messages) {
            if (message.id === id) {
                return message;
            }
        }
        throw new Errors_1.MessageDoesNotExist(`No message with id ${id} exists in the database.`);
    }
    /**
     *
     * Finds a specific message within the DBC file data by name
     *
     * @param name string
     * @returns Message
     * @error MessageDoesNotExist
     */
    getMessageByName(name) {
        try {
            const msg = this.data.messages.get(name);
            return msg;
        }
        catch (e) {
            throw new Errors_1.MessageDoesNotExist(`No message with name ${name} exists in the database.`);
        }
    }
    /**
     *
     * Returns a signal object located in a specific CAN message by name
     *
     * @param name string
     * @param messageName string
     * @returns Signal
     * @error SignalDoesNotExist
     */
    getSignalByName(name, messageName) {
        const msg = this.getMessageByName(messageName);
        const signals = msg === null || msg === void 0 ? void 0 : msg.signals;
        if (signals) {
            for (const [signal, signalObj] of signals) {
                if (signal === name) {
                    return signalObj;
                }
            }
        }
        else {
            throw new Errors_1.SignalDoesNotExist(`Signal could not be found in ${messageName}, because the
      signal list for that message is empty.`);
        }
        throw new Errors_1.SignalDoesNotExist(`Could not find ${name} in signal list.`);
    }
    /**
     *
     * @param file string
     * @returns Promise<DbcData>
     */
    load(file, throwOnError = false) {
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            (0, FileHandlers_1.validateFileExtension)(file, '.dbc');
            const fileStream = fs.createReadStream(file);
            // Note: we use the crlfDelay option to recognize all instances of CR LF
            // ('\r\n') in input.txt as a single line break.
            const rl = readline.createInterface({
                input: fileStream,
                crlfDelay: Infinity,
            });
            let data = this.initDbcDataObj();
            let lineNum = 1;
            const errMap = new Map();
            try {
                for (var rl_1 = __asyncValues(rl), rl_1_1; rl_1_1 = yield rl_1.next(), !rl_1_1.done;) {
                    const line = rl_1_1.value;
                    const parser = new dbcParser_1.default(line);
                    const parseErrors = parser.parseResult.errs;
                    if (parseErrors.length === 0) {
                        data = parser.updateData(data);
                    }
                    else {
                        if (throwOnError) {
                            throw new Error(`A syntax error occured on line ${lineNum} - Reason: ${parseErrors}`);
                        }
                        errMap.set(lineNum, parseErrors);
                    }
                    lineNum++;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (rl_1_1 && !rl_1_1.done && (_a = rl_1.return)) yield _a.call(rl_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            // Set parsing errors
            this.errors = errMap;
            // Add table data to class instance for future referencing
            this.data = data;
            return data;
        });
    }
    /**
     * Loads a DBC file syncrhonously, as opposed to the default method 'load', which is
     * a non-blocking/async call whos promise must be caught for the return data to be used.
     *
     * @param file Full file path to the dbc file, including extension
     * @returns DbcData Data contained in the dbc file
     */
    loadSync(file, throwOnError = false) {
        (0, FileHandlers_1.validateFileExtension)(file, '.dbc');
        let data = this.initDbcDataObj();
        const fileContents = fs.readFileSync(file, { encoding: 'ascii' });
        let lineNum = 1;
        const errMap = new Map();
        const lines = fileContents.split('\n');
        lines.forEach((line) => {
            const parser = new dbcParser_1.default(line);
            const parseErrors = parser.parseResult.errs;
            if (parseErrors.length === 0) {
                data = parser.updateData(data);
            }
            else {
                if (throwOnError) {
                    throw new Error(`A syntax error occured on line ${lineNum} - Reason: ${parseErrors}`);
                }
                errMap.set(lineNum, parseErrors);
            }
            lineNum++;
        });
        // Set parsing errors
        this.errors = errMap;
        // Add table data to class instance for future referencing
        this.data = data;
        return data;
    }
    /**
     *
     * Writes the encapsulated data of a Dbc class instance to a dbc file
     *
     * @param filePath Path to the file/dbc to be written to. If it does not exist at the path, the file
     * will automatically be created.
     */
    write(filePath) {
        (0, FileHandlers_1.validateFileExtension)(filePath, '.dbc');
        const writer = new Writer_1.default(filePath);
        writer.constructFile(this.data);
    }
    /**
     *
     * Transforms the internal DBC data from class instance into a JSON object/string
     *
     * @param pretty Determines if JSON output should be formatted. Defaults to true.
     * @returns JSON representation of loaded DBC data
     */
    toJson(options) {
        const replacer = (key, value) => {
            if (value instanceof Map) {
                if (key === 'valueTable' || key === 'valueTables') {
                    return Object.fromEntries(value.entries());
                }
                return Array.from(value.values()); // or with spread: value: [...value]
            }
            else {
                return value;
            }
        };
        let indent = 0;
        let pretty;
        options && options.pretty ? (pretty = options.pretty) : (pretty = true);
        if (pretty) {
            indent = 2;
        }
        const json = JSON.stringify(this.data, replacer, indent);
        return json;
    }
    initDbcDataObj() {
        return {
            version: null,
            messages: new Map(),
            description: null,
            busSpeed: null,
            nodes: new Map(),
            valueTables: new Map(),
            attributes: new Map(),
            newSymbols: [],
            environmentVariables: new Map(),
            networkBridges: new Map(),
        };
    }
}
exports.default = Dbc;
//# sourceMappingURL=Dbc.js.map