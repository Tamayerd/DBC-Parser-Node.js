"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BitUtils {
    bitGet(num, idx) {
        const bitField = this.uint8ToBinary(num).split('');
        // Assumes least significant bit starts at the end of the array
        return bitField[idx];
    }
    bitSet(num, idx, val) {
        num[num.length - idx - 1] = val;
        return num;
    }
    bin2decSigned(bits) {
        const negative = bits[0] === '1';
        if (negative) {
            let inverse = '';
            for (let i = 0; i < bits.length; i++) {
                inverse += bits[i] === '0' ? '1' : '0';
            }
            return (parseInt(inverse, 2) + 1) * -1;
        }
        else {
            return parseInt(bits, 2);
        }
    }
    bin2dec(bin) {
        return parseInt(bin, 2);
    }
    uint8ToBinary(dec) {
        const paddedBin = '000000000' + (dec >>> 0).toString(2);
        return paddedBin.substring(paddedBin.length - 8);
    }
    /**
     * Converts an uint8[] payload to a binary string
     * @param payload number[] CAN payload in decimal.
     * @param endian The type of encoding, Intel vs Motorola for the payload
     */
    payload2Binary(payload, endian) {
        let byteArray;
        if (endian === 'Intel') {
            // The splice method is here because reverse modifies
            // the original array. This could cause errors to
            // subsequent calls to this function when the top level reference is the
            // same
            byteArray = payload.slice().reverse();
        }
        else {
            byteArray = payload;
        }
        // Convert payload into binary string
        const bitField = byteArray
            .reduce((previous, current) => {
            return previous + this.uint8ToBinary(current);
        }, '')
            .split('');
        return bitField;
    }
    extractBitRange(binary, startBit, bitRange, endian) {
        let startOfBit;
        if (endian === 'Intel') {
            startOfBit = binary.length - startBit - bitRange;
        }
        else {
            const endOfBitField = 8 * Math.floor(startBit / 8) + (7 - (startBit % 8));
            // Need to account for sawtooth bit numbering in CAN messages
            startOfBit = endOfBitField - bitRange + 1;
            // startOfBit = binary.length - (binary.length - startBit + bitRange);
        }
        return binary.slice(startOfBit, startOfBit + bitRange);
    }
}
exports.default = BitUtils;
//# sourceMappingURL=BitUtils.js.map