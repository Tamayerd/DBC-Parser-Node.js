import BitUtils from './BitUtils';
import { EndianType } from '../shared/DataTypes';
import { DbcData, Message, Signal } from '../dbc/Dbc';
/**
 * The Can class offers utility functions that aid in the processing of general CAN data/information
 * It aids in the encoding/decoding of CAN messages, CAN frame creation, and more.
 *
 * The class can be loaded with a database using the setter function 'database'
 * i.e. const can = new Can(); can.database = data.
 * data in this context will need to be of the specified type (DbcData) and not the database file itself. Use the other
 * built in class for actually getting this data, such as the Dbc() class.
 */
declare class Can extends BitUtils {
    #private;
    _database: DbcData | undefined;
    constructor();
    /**
     * Setter that allows you to load in a CAN database object to used in
     * message/signal encoding and decoding
     * @param dbc DbcData
     */
    set database(dbc: DbcData);
    private messageMapTransform;
    /**
     *
     * @param id CAN ID of the message
     * @param payload Payload of the CAN message as an Uint8 Array. i.e. [255, 20, 10]
     * @param isExtended Whether or not the CAN ID is extended or standard. false by default.
     */
    createFrame(id: number, payload: number[], isExtended?: boolean): Frame;
    /**
     * General purpose CAN message decode function. Expects a CAN frame and will return a
     * BoundMessage type. The BoundMessage will have BoundSignals attached that will have
     * the decoded physical values.
     *
     * A database needs to be loaded using the database setter before messages can be decoded,
     * otherwise an error is returned.
     *
     * When decoding a message and the ID does not exist in the provided database, undefined will be
     * returned from the function. If you are live decoding data, make sure to check for the undefined condition
     * before trying to do anything with the returned data
     * @param frame CAN Frame
     * @returns BoundMessage | undefined
     */
    decode(frame: Frame): BoundMessage | undefined;
    private getMessageById;
    private applyPropsToSignalValue;
    /**
     * Similar to the decode method, but operates on a Signal specific context. Will only decode the signal provided
     * to the function. This function is useful if wanting to decode an individual signal rather than a whole message.
     *
     * signal needs to a type Signal. You can grab the signal you want referencing the Can class's _database property or
     * by providing your own by either creating it with the Dbc() class or using one provided by loading a DBC file into
     * the Dbc() class with .load() or .loadSync()
     * @param payload Uint8 number[]
     * @param signal Signal
     */
    decodeSignal(payload: Payload, signal: Signal): BoundSignal;
    /**
     *
     * Generalized function for extracting an individual value from a CAN message payload.
     *
     * @param payload number[]
     * @param startBit number
     * @param signalLength number
     * @param endian 'Motorola' | 'Intel'
     * @param signed boolean
     */
    extractValFromPayload(payload: number[], startBit: number, signalLength: number, endian: EndianType, signed: boolean): number;
    setSignalValues(): null;
    private createBoundSignal;
    /**
     * This function will create a BoundMessage from an existing database Message. If frameData is not entered as
     * an input parameter to the function, createBoundMessage() will create a BoundMessage payload based on the DLC of
     * the message. The payload will be initialized to all 0s. Assumes the message is not extended by default.
     *
     * If createBoundMessage is provided frameData, the boundMessage will be created on that context.
     * @param message Message
     * @param frameData {payload: number[], isExtended: boolean} | null
     */
    createBoundMessage(message: Message, frameData?: {
        payload: Payload;
        isExtended: boolean;
    } | null): BoundMessage;
}
export default Can;
export declare type Frame = {
    id: number;
    dlc: number;
    isExtended: boolean;
    payload: Payload;
};
export declare type BoundMessage = {
    boundData: {
        message: Message;
        frame: Frame;
    };
    boundSignals: Map<string, BoundSignal>;
    id: number;
    name: string;
    setSignalValue: (signal: string, value: number) => {};
};
export declare type BoundSignal = {
    boundData: {
        signal: Signal;
        payload: Payload;
    };
    value: number;
    rawValue: number;
    physValue: string;
    setValue: (value: number) => {};
};
export declare type Payload = number[];
